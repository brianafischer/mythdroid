#!/usr/bin/perl

=begin comment

MythDroid: Android MythTV Remote
Copyright (C) 2009-2010 foobum@gmail.com

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=end comment
=cut

use strict;
use warnings;
use IO::Socket::INET;
use IO::Select;
use File::Copy;
use Time::HiRes qw(usleep);
use MythTV;
use Sys::Hostname;

sub handleMdConn($);
sub handleDisconnect($);
sub cloneDb();
sub prepareSth($);
sub readCommands();
sub startLcdServer($);
sub connectLcdServer();
sub lcdData($);
sub lcdMenu($$);
sub lcdMusic($);
sub lcdMusicTracks($);
sub lcdMusicProgress($);
sub lcdMusicPlayer_prop($$);
sub lcdChannel($);
sub lcdChannelProgress($);
sub clientMsg($);
sub sendMsg($);
sub runCommand($);
sub videoList($);
sub streamFile($);
sub stopStreaming();
sub getRecType($);
sub getStorGroup($);
sub getStorGroups();
sub getRecGroups();
sub updateRec($$);
sub newRec($$$);
sub delRec($);
sub populateStorGroups();
sub killKids();

my $lcdServerPort = 6545;
my $listenPort = 16546;

# Kill off the real mythlcdserver when we are killed
$SIG{'INT'} = $SIG{'TERM'} = $SIG{'KILL'} = \&killKids; 
sub END { killKids() }
# Re-read mdd.conf if we are HUP'd
$SIG{'HUP'} = \&readCommands;

my $mythtv = MythTV->new(\{ 'connect' => 0 });

install() unless ($0 =~ /mythlcdserver$/);

my (
    $lastData, $lastMenu, $lastMusic, $lastChannel, $data, $lcdClient,
    $client, $dbh, $albumArtSth, $videoSth, $upnpVideoSth, $getStorGroupsSth,
    $getRecGroupsSth, $newRecSth, $progSth, $storGroupSth, $recTypeSth,
    $delRecSth, $videoDir, $cpus, $streampid
);
my $lastPos = -1;
my $size = 1024;

my (%forNewClient, %commands, %videos, %storageGroups);
my @videoFields = (
    qw(
        title subtitle director plot homepage year userrating length filename
    )
);

# SQL statements
my $albumArtSQL = 
    'SELECT DISTINCT albumart_id from music_albumart LEFT JOIN music_songs ' .
    'ON music_albumart.directory_id = music_songs.directory_id LEFT JOIN ' .
    'music_albums on music_songs.album_id = music_albums.album_id WHERE ' .
    'music_albums.album_name = ? and music_albumart.imagetype = 1';

my $videoSQL = 
    'SELECT title, subtitle, director, plot, homepage, year, userrating, ' .
    'length,filename FROM videometadata where filename REGEXP ?';
    
my $getRecGroupsSQL = 
    'SELECT DISTINCT recgroup FROM recorded WHERE recgroup != "LiveTV" AND ' .
    'recgroup != "Deleted" ORDER by recgroup';

my $progSQL =
    'SELECT program.chanid,UNIX_TIMESTAMP(starttime),UNIX_TIMESTAMP(endtime),' .
    'title,subtitle,description,category,seriesid,programid,channel.callsign ' . 
    'FROM program LEFT JOIN channel ON program.chanid = channel.chanid WHERE ' . 
    'program.chanid = ? AND starttime = FROM_UNIXTIME(?)';

my $newRecSQL = 
    'INSERT INTO record (chanid,starttime,startdate,endtime,enddate,title,' .
    'subtitle,description,category,seriesid,programid,station,next_record,' .
    'last_record,last_delete,autoexpire,autocommflag) VALUES (?,' .
    'FROM_UNIXTIME(?),FROM_UNIXTIME(?),FROM_UNIXTIME(?),FROM_UNIXTIME(?),' .
    '?,?,?,?,?,?,?,\'00:00:00\',\'00:00:00\',\'00:00:00\',1,1)';

my $updateRecSQL = 
    'UPDATE record SET %UPDATES% where recordid = %RECID%';

my $delRecSQL = 
    'DELETE FROM record where recordid = ?';

my $upnpVideoSQL     = 'SELECT intid FROM upnpmedia WHERE filepath = ?';
my $getStorGroupsSQL = 'SELECT groupname,dirname FROM storagegroup';
my $recTypeSQL       = 'SELECT type FROM record WHERE recordid = ?';
my $storGroupSQL     = 'SELECT storagegroup FROM record WHERE recordid = ?';

# Use ffmpeg to demux and decode; VLC's TS demuxer doesn't cope with 
# a significant proportion of dvb recordings :(
my $stream_cmd = 
    'ffmpeg -i %FILE% -vcodec rawvideo -acodec pcm_s16le -deinterlace ' .
    '-s %WIDTH%x%HEIGHT% -ac 2 -ar 48000 -copyts -async 100 -f asf -y - ' .
    '2>/tmp/ffmpeg.out | /usr/bin/vlc -vvv -I dummy - --sout=\'' .
    '#transcode{vcodec=h264,venc=x264{no-cabac,level=30,keyint=250,ref=4,' .
    'bframes=0},vb=%VB%,threads=%THR%,width=%WIDTH%,height=%HEIGHT%,' .
    'acodec=mp4a,samplerate=48000,ab=%AB%,channels=2}' .
    ':rtp{sdp=rtsp://0.0.0.0:5554/stream}\' >/tmp/vlc.out 2>&1';

readCommands();

startLcdServer(join(" ", @ARGV));

# Listen for connections from mythfrontend
my $lcdListen = IO::Socket::INET->new(
    Listen => 1,
    Proto => 'tcp',
    ReuseAddr => 1,
    LocalPort => $lcdServerPort
) or die "Listen on $lcdServerPort/tcp: $!\n";

# Listen for connections from MythDroid
my $listen = IO::Socket::INET->new(
    Listen => 1,
    Proto => 'tcp',
    ReuseAddr => 1,
    LocalPort => $listenPort
) or die "Listen on $listenPort/tcp: $!\n";

my $s = IO::Select->new($lcdListen, $listen);

# Connect to the real mythlcdserver
my $lcdServer = connectLcdServer();
$s->add($lcdServer);
    
# Connect to the database, prepare queries
$dbh = cloneDb();

# Main Loop
while (my @ready = $s->can_read) {
    
    foreach my $fd (@ready) {
        
        if ($fd == $lcdListen) {
            # New connection from mythfrontend
            if ($lcdClient = $fd->accept) {
                $s->add($lcdClient);
            }
            next;
        }

        elsif ($fd == $listen) {
            # New connection from MythDroid
            handleMdConn($fd);
            next;
        }

        unless (sysread($fd, $data, $size)) {
            # Someone disconnected
            handleDisconnect($fd);
            next;
        }

        if ($fd == $lcdServer) {
            # Ferry data from lcdserver -> mythfrontend
            syswrite($lcdClient, $data);
        }
        elsif ($client && $fd == $client) {
            # From MythDroid
            $data =~ s/\r//;
            clientMsg($data);
        }
        else {
            # Process and ferry data from mythfrontend -> lcdserver
            foreach (split /\n/, $data) { lcdData($_) if length > 4 }
            syswrite($lcdServer, $data);
        }

    }

}

# Handle new connection from MythDroid
sub handleMdConn($) {

    my $fd = shift;

    if (defined $client) {
        $s->remove($client);
        $client->close;
    }

    if ($client = $fd->accept) {
        $s->add($client);
        # Send a list of MDD commands
        foreach my $key (keys %commands) {
            syswrite($client, "COMMAND $key\n");
        }
        syswrite($client, "COMMANDS DONE\n");
        # Send last LCD statuses 
        foreach my $key (keys %forNewClient) {
            syswrite($client, $forNewClient{$key});
        }

    }

}

sub handleDisconnect($) {

    my $fd = shift;

    # Someone disconnected
    $s->remove($fd);
    $fd->close;
    undef $client if (defined $client && ($fd == $client));
    if ($fd == $lcdServer) {
        # Reconnect if we lost connection to the real mythlcdserver
        $lcdServer = connectLcdServer();
        $s->add($lcdServer);
    }

}

sub cloneDb() {
    $dbh = $mythtv->{dbh};
    return $dbh->clone;
}

# Prepare a MySQL statement handle, pass a ref to the SQL string
sub prepareSth($) {
    my $sqlref = shift;
    my $sth;

    unless ($sth = $dbh->prepare($$sqlref)) {
        $dbh = cloneDb();
        return prepareSth($sqlref);
    }

    return $sth;
}

# Parse MDD commands from /etc/mdd.conf
sub readCommands() {

    %commands = ();
    
    open F, '</etc/mdd.conf' or return;

    my $line = 0;

    while (<F>) {
        $line++;
        s/^\s+//;
        s/\s+$//;
        next if /^#/;
        s/#.*$//;
        my ($name, $cmd) = /(.*)=>(.*)/;
        if (!($name && $cmd)) {
            warn("Error parsing line $line of /etc/mdd.conf");
            next;
        }
        $name =~ s/\s+$//;
        $cmd =~ s/^\s+//;
        $commands{$name} = $cmd;
    }

    close F;
}

sub startLcdServer($) {

    my $args = shift;

    $args =~ s/&$//;

    system("ps ax | grep 'mythlcd ' | grep -v grep >/dev/null");

    return if ($? == 0);

    if ($args =~ /-p\s*(\d+)/) {
        $lcdServerPort = $1;
        my $p = $lcdServerPort + 1000;
        $args =~ s/-p\s*(\d+)/-p $p/;
    }
    else {
        $args .= " -p " . ($lcdServerPort + 1000);
    }

    system("mythlcd $args &");

}

sub connectLcdServer() {

    foreach (0 .. 4) {
    
        $lcdServer = IO::Socket::INET->new(
            Proto => 'tcp',
            PeerAddr => '127.0.0.1',
            PeerPort => $lcdServerPort + 1000
        ) and return $lcdServer;

        usleep(600000);
        next;

    }

    die "Can't connect to LCD server\n"; 

}

# Process LCD commands
sub lcdData($) {

    my $data = shift;

    return if (defined $lastData && $data eq $$lastData);

    $lastData = \$data;

    if ($data =~ s/^SWITCH_TO_MENU\s+"MYTH-([^"]+)"\s+//) {
        lcdMenu($1, $data);
    }
    elsif ($data =~ s/^SWITCH_TO_MUSIC\s+//) {
        lcdMusic($data);
    }
    elsif ($data =~ /^SET_MUSIC_PROGRESS.*?([\.\d]+)$/) {
        lcdMusicProgress($1);
    }
    elsif ($data =~ /^SET_MUSIC_PLAYER_PROP\s+(\w+)\s+(\w+)/) {
        lcdMusicPlayerProp($1, $2);
    }
    elsif ($data =~ s/^SWITCH_TO_CHANNEL\s+//) {
        lcdChannel($data);
    }
    elsif ($data =~ /^SET_CHANNEL_PROGRESS\s+([\.\d]+)/) {
        lcdChannelProgress($1);
    }
    elsif ($data =~ /^SWITCH_TO_TIME/) {
        sendMsg("DONE");
    }

}

sub lcdMenu($$) {
    
    my $menu = shift;
    my $items = shift;

    return if (defined $lastMenu && $items eq $$lastMenu);

    $lastMenu = \$items;
    undef $lastMusic;
    undef $lastChannel;
    $lastPos = -1;

    my @menu;

    my (@items) = $data =~ 
        /"([^"]+)"\s+NOTCHECKABLE\s+(\w+)/g;

    my $idx = 0;
    my $curidx;
    
    while (my $item = shift @items) {
        my $cur = shift @items;
        push @menu, { 'item' => $item, 'cur' =>  $cur };
        $curidx = $idx if $cur eq 'TRUE';
        $idx++;
    }

    my $msg = "MENU $menu ITEM $menu[$curidx]->{item}";
    
    $forNewClient{'menu'} = $msg . "\n";

    sendMsg($msg);

}

sub lcdMusic($) {

    my $data = shift;
    my $albumartId;

    return if (defined $lastMusic && $data eq $$lastMusic);

    $lastMusic = \$data;

    my ($artist, $album, $track) = $data =~
        /^"([^"]+)"\s+"([^"]+)"\s+"([^"]+)"$/;

    my $msg = "MUSIC $artist ALBUM $album TRACK $track";
    
    unless ($albumArtSth && $albumArtSth->execute($album)) {
        $albumArtSth = prepareSth(\$albumArtSQL);
        $albumArtSth->execute($album);
    }

    if (my $aref = $albumArtSth->fetchrow_arrayref) {
        $albumartId = $aref->[0];
    }

    $msg .= " ARTID $albumartId" if (defined $albumartId);

    $forNewClient{'music'} = $msg . "\n";

    sendMsg($msg);

}

sub lcdMusicProgress($) {

    my $pos = shift;

    $pos = sprintf "%.2f", $pos;
    
    $pos *= 100;

    return unless $pos % 2;
    return if ($pos == $lastPos);
    $lastPos = $pos;

    sendMsg("MUSICPROGRESS $pos");

}

sub lcdMusicPlayerProp($$) {

    my $prop = shift;
    my $val = shift;

    sendMsg("MUSICPLAYERPROP $prop $val");
}

sub lcdChannel($) {

    my $data = shift; 

    return if (defined $lastChannel && $data eq $$lastChannel);

    $lastChannel = \$data;

    my ($chan, $title, $subtitle) = $data =~ /^"([^"]+)"\s+"([^"]+)"\s+"([^"]*)"$/;

    my $msg;

    if ($chan) {
        $msg = "CHANNEL $chan TITLE $title";
    }
    elsif ($title) {
        $msg = "CHANNEL Video TITLE $title";
    }
    else {
        return;
    }

    $msg .= " SUBTITLE $subtitle" if $subtitle;
    
    $forNewClient{'channel'} = $msg . "\n";

    sendMsg($msg);

}

sub lcdChannelProgress($) {

    my $pos = shift;

    $pos = sprintf "%.3f", $pos;
    
    $pos *= 1000;

    return unless $pos % 2;
    return if ($pos == $lastPos);
    $lastPos = $pos;

    sendMsg("CHANNELPROGRESS $pos");

}

# Send a message to the client (MythDroid)
sub sendMsg($) {

    my $msg = shift;
    $msg .= "\n";
    syswrite($client, $msg) if (defined $client);

}

# Process messages from the cliet (MythDroid)
sub clientMsg($) {

    my $msg = shift;

    if ($msg =~ /^COMMAND (.*)$/) {
        sendMsg("OK");
        runCommand($1);
    }
    elsif ($msg =~ /VIDEOLIST (.*)$/) {
        sendMsg("OK");
        videoList($1);
    }
    elsif ($msg =~ /STREAM (.*)$/) {
        sendMsg("OK");
        streamFile($1);
    }
    elsif ($msg =~ /STOPSTREAM/) {
        sendMsg("OK");
        stopStreaming();
    }
    elsif ($msg =~ /RECTYPE (\d+)$/) {
        sendMsg("OK");
        getRecType($1);
    }
    elsif ($msg =~ /STORGROUP (\d+)$/) {
        sendMsg("OK");
        getStorGroup($1);
    }
    elsif ($msg =~ /STORGROUPS/) {
        sendMsg("OK");
        getStorGroups();
    }
    elsif ($msg =~ /RECGROUPS/) {
        sendMsg("OK");
        getRecGroups();
    }
    elsif ($msg =~ /UPDATEREC (\d+) (.*)$/) {
        sendMsg("OK");
        updateRec($1, $2);
    }
    elsif ($msg =~ /NEWREC (\d+) (\d+) (.*)$/) {
        sendMsg("OK");
        newRec($1, $2, $3);
    }
    elsif ($msg =~ /DELREC (\d+)$/) {
        sendMsg("OK");
        delRec($1);
    }
    else {
        sendMsg("UNKNOWN");
    }

}

# Run an MDD command
sub runCommand($) {
    
    my $cmd = shift;

    if (! exists $commands{$cmd}) {
        warn("mdd command $cmd is not defined");
        return;
    }

    system($commands{$cmd});

}

# Get a list of videos in given directory
sub videoList($) {

    my $subdir = shift;

    %videos = ();

    unless ($videoDir) { 
        $videoDir = $mythtv->backend_setting('VideoStartupDir', hostname());
    }

    my $regexp = "$videoDir/";

    $regexp .= "$subdir/" unless ($subdir eq 'ROOT');

    $regexp =~ s/'/\'/;

    my @dirs = grep(
        /\S+/, 
        map { chomp; s/^$regexp//; $_ } `find -L '$regexp' -maxdepth 1 -type d`
    );

    $regexp .= '[^/]+$';
    
    unless ($videoSth && $videoSth->execute($regexp)) {
        $videoSth = prepareSth(\$videoSQL);
        $videoSth->execute($regexp);
    }
    
    while (my $aref = $videoSth->fetchrow_arrayref) {
        my $path = $aref->[8];
        unless ($upnpVideoSth && $upnpVideoSth->execute($path)) {
            $upnpVideoSth = prepareSth(\$upnpVideoSQL);
            $upnpVideoSth->execute($path);
        }
        my $id = ($upnpVideoSth->fetchrow_arrayref)->[0];
        my %h;
        @h{@videoFields} = @$aref;
        $videos{$id} = \%h;
    }

    foreach my $dir (@dirs) {
        sendMsg("DIRECTORY $dir");
    }

    foreach my $id (keys %videos) {
        my $msg = "VIDEO $id";
        foreach my $f (
            map { '||' . $videos{$id}{$_} } @videoFields
        ) { $msg .= $f }
        sendMsg($msg);
    }

    sendMsg("VIDEOLIST DONE");

}

# Stream a recording or video
sub streamFile($) {
    
    my $file = shift;
    my $dir;
    my $pat = qr/(\d+)x(\d+)\s+VB\s+(\d+)\s+AB\s+(\d+)\s+SG\s+(.+)\s+FILE\s+/;

    my ($width, $height, $vb, $ab, $sg) = $file =~ /$pat/;
    $file =~ s/$pat//;

    unless (defined $cpus) {
        my $buf;
        open CPUS, "</sys/devices/system/cpu/present";
        read CPUS, $buf, 64;
        $cpus = () = $buf =~ /(\d+)/g;
        close CPUS;
    }

    if ($file =~ /^myth:\/\//) {

        populateStorGroups() unless (scalar %storageGroups);
    
        $file =~ s/.*\//\//;

        if (exists $storageGroups{$sg}) {
            $file = $storageGroups{$sg} . $file;
        }
        else {
            $file = $storageGroups{'Default'} . $file;
        }

    }
    else {
        $file =~ s/ /\\ /g;
    }

    my $cmd = $stream_cmd;
    $cmd =~ s/%FILE%/$file/;
    $cmd =~ s/%VB%/$vb/;
    $cmd =~ s/%AB%/$ab/;
    $cmd =~ s/%THR%/$cpus/;
    $cmd =~ s/%WIDTH%/$width/g;
    $cmd =~ s/%HEIGHT%/$height/g;

    if (($streampid = fork()) == 0) { 
        system($cmd); 
        exit 0;
    }

}

# Stop streaming a recording or video
sub stopStreaming() {

    return unless $streampid;

    # I'd like to setpgrp in the child but that
    # seems to cause vlc issues :(
    kill 'KILL', $streampid, $streampid+1, $streampid+2, $streampid+3;
    waitpid $streampid, 0;
    undef $streampid;

}

# Get the recording type from a recid
sub getRecType($) {

    my $recid = shift;
        
    unless ($recTypeSth && $recTypeSth->execute($recid)) {
      $recTypeSth = prepareSth(\$recTypeSQL);
      $recTypeSth->execute($recid);
    }

    if (my $aref = $recTypeSth->fetchrow_arrayref) {
        sendMsg($aref->[0]);
    }
    else {
        sendMsg("0");
    }

}

# Get the storage group from a recid
sub getStorGroup($) {

    my $recid = shift;
        
    unless ($storGroupSth && $storGroupSth->execute($recid)) {
      $storGroupSth = prepareSth(\$storGroupSQL);
      $storGroupSth->execute($recid);
    }

    if (my $aref = $storGroupSth->fetchrow_arrayref) {
        sendMsg($aref->[0]);
    }
    else {
        sendMsg("Default");
    }

}

# Get a list of storage groups
sub getStorGroups() {

    populateStorGroups() unless (scalar %storageGroups);

    foreach my $grp (keys %storageGroups) {
        sendMsg($grp);
    }

    sendMsg("STORGROUPS DONE");

}

# get a list of recording groups
sub getRecGroups() {
    
    unless ($getRecGroupsSth && $getRecGroupsSth->execute()) {
        $getRecGroupsSth = prepareSth(\$getRecGroupsSQL);
        $getRecGroupsSth->execute();
    }

    while (my $aref = $getRecGroupsSth->fetchrow_arrayref) {
        sendMsg($aref->[0]);
    }

    sendMsg("RECGROUPS DONE");

}

# Update an existing recording rule
sub updateRec($$) {

    my $recid = shift;
    my $updates = shift;

    my $sql = $updateRecSQL;
    $sql =~ s/%UPDATES%/$updates/;
    $sql =~ s/%RECID%/$recid/;

    my $rv;

    unless (($rv = $dbh->do($sql))) {
        cloneDb();
        $rv = $dbh->do($sql);
    }

    $recid = -1 if ($rv < 1);

    sendMsg($recid);

}

# Create a new recording rule
sub newRec($$$) {
    
    my $chanid = shift;
    my $starttime = shift;
    my $updates = shift;

    my @prog;
    
    unless ($progSth && $progSth->execute($chanid, $starttime)) {
        $progSth = prepareSth(\$progSQL);
        $progSth->execute($chanid, $starttime);
    }

    my $aref = $progSth->fetchrow_arrayref;

    $prog[0] = $aref->[0];
    $prog[1] = $prog[2] = $aref->[1];
    $prog[3] = $prog[4] = $aref->[2];
    push @prog, @{$aref}[3..$#{$aref}];

    unless ($newRecSth && $newRecSth->execute(@prog)) {
        $newRecSth = prepareSth(\$newRecSQL);
        $newRecSth->execute(@prog);
    }
    
    my $recid = $dbh->last_insert_id(undef,undef,undef,undef);

    updateRec($recid, $updates);

}

# Delete a recording rule
sub delRec($) {

    my $recid = shift;

    unless ($delRecSth && $delRecSth->execute($recid)) {
        $delRecSth = prepareSth(\$delRecSQL);
        $delRecSth->execute($recid);
    }

}

# Populate the global storageGroups hash
sub populateStorGroups() {
    unless ($getStorGroupsSth && $getStorGroupsSth->execute()) {
        $getStorGroupsSth = prepareSth(\$getStorGroupsSQL);
        $getStorGroupsSth->execute();
    }

    while (my $aref = $getStorGroupsSth->fetchrow_arrayref) {
        $storageGroups{$aref->[0]} = $aref->[1];
    }
}

# Kill the original mythlcdserver
sub killKids() {
    my @ps = `ps ax | grep 'mythlcd ' | grep -v grep`;
    foreach my $ps (@ps) {
       if ($ps =~ /^\s*(\d+)/) {
            kill 'TERM', $1;
        }
    }
}

sub install {

    print "Installing mdd..\n";
    print "Stopping mythfrontend and mythlcdserver\n";
    system(
        "killall mythfrontend 2>/dev/null;" .
        "killall mythfrontend.real 2>/dev/null;" . 
        "killall mythlcdserver 2>/dev/null"
    );
    my $path = (`which mythlcdserver`)[0];
    $path =~ s/\/mythlcdserver$//;
    chomp $path;
    unless ((`file $path/mythlcdserver`)[0] =~ /perl/) {
        print "cp $path/mythlcdserver -> $path/mythlcd\n";
        copy("$path/mythlcdserver", "$path/mythlcd") or die "$!\n";
        chmod(0755, "$path/mythlcd")or warn "chmod of $path/mythlcd failed\n";

    }
    print "cp $0 -> $path/mythlcdserver\n";
    copy($0, "$path/mythlcdserver") or die "$!\n";
    chmod(0755, "$path/mythlcdserver") 
        or warn "chmod of $path/mythlcdserver failed\n";
    print "Check settings..\n";
    my $host = (`hostname`)[0];
    chomp $host;
    unless (
        $mythtv->backend_setting('LCDEnable', $host)      &&
        $mythtv->backend_setting('LCDShowMenu', $host)    &&
        $mythtv->backend_setting('LCDShowMusic', $host)   &&
        $mythtv->backend_setting('LCDShowChannel', $host) 
    ) {
        print "\nNOTICE: Please enable all MythTV LCD options\n";
    }
    print "Done - you can restart mythfrontend now..\n";
    exit;

}
